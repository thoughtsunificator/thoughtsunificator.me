<!doctype html>
<html lang="en">
	<head>
	<!-- A real motherfucking head just like we planned, let see: -->
		<title>Why is there still no standard way to express external programs as dependencies? | thoughtsunificator.me</title>
		<!-- Used mostly for emojis -->
		<meta charset="UTF-8">
		<!-- Because it sucks to read as if you're reading from ten feets away when in reality your smartphone is glued to your face -->
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Just a few millions of lines, mostly useless and pathetic "aesthetics" black magick kind of stuff -->
		<link rel="stylesheet" type="text/css" href="/main.css">
		<!-- Used for syntax highlighting inside posts -->
		<link rel="stylesheet" type="text/css" href="/okaida.css">
		<!-- https://w3c.github.io/manifest/ -->
		<link rel="manifest" href="/manifest.webmanifest">
	</head>
	<body class="">
		<main id="main">
			
	<article class="post full">
		
		<div class="metas">
			
			<div class="tags">
				
			</div>
		</div>
		
		<div id="post-content"><p>What's the point of shebangs anyway? Some will tell you that you better use /usr/bin/env bash over /usr/bin/bash, they will argue that env does not directly point to a path instead it looks for the bash binary in your existing PATH variable. Truth to be told, no one cares, they both fail at the very basic thing at which they aim for.</p>
<p>That is, expressing an external program as a dependency, one who writes a shell script and want to share it, better make make as little assumptions as possible, this starts with expressing dependencies.</p>
<p>When we think of dependencies, more than often we think of pkgconf, autotool, cmake, C libraries and such, leaving out the important fact that there might be need for x/y external program, however, for some reason, it is never explicitly expressed. It's as if it would already be magically installed in the exact version that is needed for the task at hand.</p>
<p>The better anyone could come up with so far is not caring about it, leaving it up to someone else, probably at at lower level of stack (hello evil packagers), ultimately condemning the user to face a software failure sometime even as soon as the <a href="https://github.com/mesonbuild/meson/issues/15539">building process</a>. Yes, you read that right, a build system that expect its users to have already assembled the pieces of the software they're building. Meson is not the only one wrong in this case, Python is too, for it is well-known for its poor dependencies management, I won't get too deep into that part but let's say that they cannot decide on a common way to do things and their package manager, pip, is known to introduce breaking changes every single update. Anyway, who did not once try to run a Python script only to have to reverse engineer its entire dependencies tree in order to be able to run it? This does not happen &quot;just because&quot;, it happens because Python users are bad at expressing their script's dependencies, they often overlook the <a href="/version-pinning-does-not-mean-what-we-think-it-means">managing my dependencies versions</a> part of having dependencies. Python packager are also under the false pretense that suffixing Python binary with its major and minor version is enough. For Python, <a href="https://www.pkgsrc.org">things do seems to be getting better</a> on the standardization part that is.</p>
<p>So, as you can see lots of wrong from lots of people, that makes for a poor UX/DX, so what can be done about that?</p>
<p>We need two things:</p>
<ol>
<li>A standard, common way, to express external program as dependencies, a manifest</li>
<li>A intermediate program that is able to lookup dependencies on any given system</li>
</ol>
<p>This way this gives both the final user, maintainers and developers more freedom while keeping us sane.<br>
It is not the program's job to install anything, that is part of the build process, its job to tell the build process about the dependency, what exactly it is and how it can use it. In contrast to the current state of things where a path means a dependency, the program would look at the user intents from previously installed packages and test their hashes, that is, the clearest form to express a dependency.</p>
<p>Another more present option would be to create that said program yourself, through a POSIX compliant shell script, make sure that the program exists and in the exact version that you need it. Needless to say that it's not as simple as <code>find_program(&quot;python_module&quot;)</code> huge shout-out to the dumbest of all: meson.</p>
<p>That's it I will no longer be fooled by semver, paths and /usr/bin/env, suffixes or anything of the sort.</p>
</div>
	</article>
		</main>
		<footer id="footer">
			<nav>
				<a href="/">Home</a><a href="/tags/">Tags</a><a href="/about/">About</a><a href="/manifesto/">Manifesto</a>
				<div class="icons" style="filter: invert(1)">
					<a title="Github" target="_blank" rel="noopener" href="https://github.com/thoughtsunificator">
						<img width="32" alt="View source code on Github" src="/image/github.svg">
					</a>
				</div>
		</nav>
			<span class="tagline">a boundless expression of thoughts</span>
			<span>Built with <a rel="noreferrer" target="_blank" href="https://www.11ty.dev/">Eleventy</a><br>Inspired by <a rel="noreferrer" target="_blank" href="http://motherfuckingwebsite.com">a certain website...</a></span>
		</footer>
	</body>
</html>