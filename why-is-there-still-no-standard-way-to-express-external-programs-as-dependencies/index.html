<!doctype html>
<html lang="en">
	<head>
	<!-- A real motherfucking head just like we planned, let see: -->
		<title>Why is there still no standard way to express external programs as dependencies? | thoughtsunificator.me</title>
		<!-- Used mostly for emojis -->
		<meta charset="UTF-8">
		<!-- Because it sucks to read as if you're reading from ten feets away when in reality your smartphone is glued to your face -->
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Just a few millions of lines, mostly useless and pathetic "aesthetics" black magick kind of stuff -->
		<link rel="stylesheet" type="text/css" href="/main.css">
		<!-- Used for syntax highlighting inside posts -->
		<link rel="stylesheet" type="text/css" href="/okaida.css">
		<!-- https://w3c.github.io/manifest/ -->
		<link rel="manifest" href="/manifest.webmanifest">
	</head>
	<body class="">
		<main id="main">
			
	<article class="post full">
		
		<div class="metas">
			
			<div class="tags">
				
			</div>
		</div>
		
		<div id="post-content"><p>What's the point of #! constructs anyway? According to the POSIX spec:</p>
<blockquote>
<p>Applications should note that the standard PATH to the shell cannot be assumed to be either /bin/sh or /usr/bin/sh, and should be determined by interrogation of the PATH returned by getconf PATH, ensuring that the returned path name is an absolute path name and not a shell built in.</p>
</blockquote>
<p>It tells us that we should prefer /usr/bin/env bash over /usr/bin/bash, the spec argues that env does not directly point to a path, instead, it looks for the bash binary in your existing PATH variable using getconf. Truth to be told, no one cares, they both fail at the very basic thing at which they aim for.</p>
<p>That is, expressing an external program as a dependency, one who writes a shell script and want to share it, better make make as little assumptions as possible, this starts with expressing dependencies.</p>
<p>When we think of dependencies, more than often we think of pkgconf, autotool, cmake, C libraries and such, leaving out the important fact that there might be need for x/y external program, however, for some reason, it is never explicitly expressed. It's as if it would already be magically installed in the exact version that is needed for the task at hand.</p>
<p>The better anyone could come up with so far is not caring about it, leaving it up to someone else, probably at at lower level of stack (hello evil packagers), ultimately condemning the user to face a software failure sometime even as soon as the <a href="https://github.com/mesonbuild/meson/issues/15539">building process</a>. Yes, you read that right, a build system that expects its users to have already assembled the pieces of the software they're building. Meson is not the only one wrong in this case, Python is too, for it is well-known for its poor dependencies management, I won't get too deep into that part but let's say that they cannot decide on a common way to do things and their package manager, pip, is known to introduce breaking changes every single update. Who did not once try to run a Python script only to have to reverse engineer its entire dependencies tree just to be able to run the damn thing? This kind of poor DX does not happen &quot;simply because&quot;, it happens because Python users are very bad at expressing their scripts dependencies, they more than often overlook the <a href="/version-pinning-does-not-mean-what-we-think-it-means">managing my dependencies versions</a> part of having dependencies at all. And that's not all! Python packagers also seem to be under the false pretense that suffixing any Python binary with its major and minor version is enough.</p>
<p>On another hand, for Python's own packaging ecosystem, <a href="https://peps.python.org/pep-0723">things do seems to be getting better</a> on the standardization part that is.</p>
<p>So, as you can see lots of wrong from lots of people, that makes for a poor UX/DX, so what can be done about that?</p>
<p>We need more than just a single unified symbol to express dependencies, we need the at the very least:</p>
<ol>
<li>A very brief and standardized way to express external programs as dependencies through a manifest</li>
<li>An (neutral) intermediate program that is able to lookup dependencies through some sort of universal registry that records user intents on any given system</li>
</ol>
<p>This way this gives both the final user, maintainers and developers more freedom while keeping us sane.</p>
<p>When external programs are required at any steps of that building process then it should be able to be lookup the information whether a given program is available, what exactly it is and how it can use it. In contrast to the current state of things where a path, symbolically, means a dependency, the program would look at the user intents from previously installed packages and test their hashes, that is, the clearest form to express a dependency. The hash would be made ouf of their name, their exact and precise version. A clear distinction should be made between programs that the user himself compiled and installed programs, unless again, it expressed its intent to compile a precise version as-is without chaining its behavior. It's all about what the user want.</p>
<p>Needless to say that it is not as simple as providing an API that calls itself <a href="https://mesonbuild.com/Reference-manual_functions.html#find_program">find_program</a>: huge shout-out to the dumbest of all: <a href="https://github.com/mesonbuild/meson">meson</a> which by the way looks like another attempt at world wide domination through softwares enslaving its users.</p>
<p>That's it I will no longer be fooled by semver, paths and /usr/bin/env, suffixes or anything of the sort.</p>
</div>
	</article>
		</main>
		<footer id="footer">
			<nav>
				<a href="/">Home</a><a href="/tags/">Tags</a><a href="/about/">About</a><a href="/manifesto/">Manifesto</a>
				<div class="icons" style="filter: invert(1)">
					<a title="Github" target="_blank" rel="noopener" href="https://github.com/thoughtsunificator">
						<img width="32" alt="View source code on Github" src="/image/github.svg">
					</a>
				</div>
		</nav>
			<span class="tagline">a boundless expression of thoughts</span>
			<span>Built with <a rel="noreferrer" target="_blank" href="https://www.11ty.dev/">Eleventy</a><br>Inspired by <a rel="noreferrer" target="_blank" href="http://motherfuckingwebsite.com">a certain website...</a></span>
		</footer>
	</body>
</html>